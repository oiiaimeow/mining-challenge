import * as fs from "fs";
import * as path from "path";

/**
 * Script to generate frontend ABI and address files from deployment artifacts
 * This script automatically reads deployment information and updates frontend files
 * Skips networks where the contract is not deployed
 */
async function generateFrontendABI() {
  const contractName = "MiningChallenge";
  const deploymentsDir = path.join(__dirname, "..", "deployments");
  const frontendAbiDir = path.join(__dirname, "..", "..", "frontend", "abi");
  
  // Ensure frontend ABI directory exists
  if (!fs.existsSync(frontendAbiDir)) {
    fs.mkdirSync(frontendAbiDir, { recursive: true });
  }

  // Read all network directories
  const networks: string[] = [];
  if (fs.existsSync(deploymentsDir)) {
    const entries = fs.readdirSync(deploymentsDir, { withFileTypes: true });
    for (const entry of entries) {
      if (entry.isDirectory()) {
        networks.push(entry.name);
      }
    }
  }

  // Chain ID mapping
  const chainIdMap: Record<string, number> = {
    hardhat: 31337,
    localhost: 31337,
    sepolia: 11155111,
    anvil: 31337,
  };

  // Chain name mapping
  const chainNameMap: Record<string, string> = {
    hardhat: "Hardhat Local",
    localhost: "Localhost",
    sepolia: "Sepolia",
    anvil: "Anvil Local",
  };

  const addresses: Record<string, { address?: `0x${string}`; chainId?: number; chainName?: string }> = {};
  let contractABI: any[] = [];

  // Process each network
  for (const network of networks) {
    const deploymentFile = path.join(deploymentsDir, network, `${contractName}.json`);
    
    if (!fs.existsSync(deploymentFile)) {
      console.log(`Skipping ${network}: ${contractName} not deployed`);
      continue;
    }

    try {
      const deployment = JSON.parse(fs.readFileSync(deploymentFile, "utf-8"));
      const chainId = chainIdMap[network] || deployment.chainId;
      
      if (!chainId) {
        console.log(`Skipping ${network}: chainId not found`);
        continue;
      }

      const address = deployment.address as `0x${string}`;
      const chainName = chainNameMap[network] || network;

      addresses[chainId.toString()] = {
        address,
        chainId,
        chainName,
      };

      // Get ABI from deployment if not already set
      if (contractABI.length === 0 && deployment.abi) {
        contractABI = deployment.abi;
      }

      console.log(`Found deployment on ${network} (chainId: ${chainId}): ${address}`);
    } catch (error) {
      console.error(`Error reading deployment for ${network}:`, error);
    }
  }

  // If no ABI found in deployments, try to read from artifacts
  if (contractABI.length === 0) {
    // Try new path structure (src directory)
    let artifactPath = path.join(__dirname, "..", "artifacts", "src", `${contractName}.sol`, `${contractName}.json`);
    if (!fs.existsSync(artifactPath)) {
      // Fallback to old path structure (contracts directory)
      artifactPath = path.join(__dirname, "..", "artifacts", "contracts", `${contractName}.sol`, `${contractName}.json`);
    }
    
    try {
      if (fs.existsSync(artifactPath)) {
        const artifact = JSON.parse(fs.readFileSync(artifactPath, "utf-8"));
        contractABI = artifact.abi;
        console.log("ABI loaded from artifacts");
      }
    } catch (error) {
      console.error("Error reading artifact:", error);
    }
  }

  // Generate ABI file
  const abiFilePath = path.join(frontendAbiDir, `${contractName}ABI.ts`);
  const abiContent = `// Auto-generated ABI file
// This file is automatically generated from contract artifacts
export const ${contractName}ABI = {
  abi: ${JSON.stringify(contractABI, null, 2)} as const,
} as const;
`;

  fs.writeFileSync(abiFilePath, abiContent, "utf-8");
  console.log(`✓ Generated ABI file: ${abiFilePath}`);

  // Generate addresses file
  const addressesFilePath = path.join(frontendAbiDir, `${contractName}Addresses.ts`);
  
  // Preserve existing entries that are not in our deployment data
  const existingAddresses: Record<string, any> = {};
  if (fs.existsSync(addressesFilePath)) {
    try {
      const existingContent = fs.readFileSync(addressesFilePath, "utf-8");
      // Extract existing addresses using regex (simple approach)
      const chainIdRegex = /"(\d+)":\s*\{[^}]*address:\s*(undefined|0x[a-fA-F0-9]+)/g;
      let match;
      while ((match = chainIdRegex.exec(existingContent)) !== null) {
        const chainId = match[1];
        if (!addresses[chainId]) {
          // Try to preserve existing structure
          const chainNameMatch = existingContent.match(new RegExp(`"${chainId}"[^}]*chainName:\\s*"([^"]+)"`));
          const addressMatch = existingContent.match(new RegExp(`"${chainId}"[^}]*address:\\s*(undefined|0x[a-fA-F0-9]+)`));
          existingAddresses[chainId] = {
            address: addressMatch && addressMatch[1] !== "undefined" ? addressMatch[1] : undefined,
            chainId: parseInt(chainId),
            chainName: chainNameMatch ? chainNameMatch[1] : `Chain ${chainId}`,
          };
        }
      }
    } catch (error) {
      console.warn("Could not parse existing addresses file, will create new one");
    }
  }

  // Merge existing addresses with new ones (new addresses override existing ones)
  const allAddresses = { ...existingAddresses, ...addresses };

  // Ensure Sepolia (11155111) is in the addresses (only if not already present)
  if (!allAddresses["11155111"]) {
    allAddresses["11155111"] = {
      address: undefined,
      chainId: 11155111,
      chainName: "Sepolia",
    };
  }

  // Ensure Hardhat (31337) is in the addresses (only if not already present)
  // Note: This won't override if address already exists from deployment
  if (!allAddresses["31337"]) {
    allAddresses["31337"] = {
      address: undefined,
      chainId: 31337,
      chainName: "Hardhat Local",
    };
  } else if (!allAddresses["31337"].chainName) {
    // Update chainName if address exists but chainName is missing
    allAddresses["31337"].chainName = allAddresses["31337"].chainName || "Hardhat Local";
  }

  const addressesContent = `// Contract addresses by chain ID
// This file is automatically generated from deployment artifacts
export const ${contractName}Addresses: Record<string, { address?: \`0x\${string}\`; chainId?: number; chainName?: string }> = ${JSON.stringify(allAddresses, null, 2)};
`;

  fs.writeFileSync(addressesFilePath, addressesContent, "utf-8");
  console.log(`✓ Generated addresses file: ${addressesFilePath}`);

  // Summary
  console.log("\n=== Summary ===");
  console.log(`Networks processed: ${networks.length}`);
  console.log(`Addresses found: ${Object.keys(addresses).length}`);
  console.log(`ABI functions: ${contractABI.filter((item) => item.type === "function").length}`);
}

// Run the script
if (require.main === module) {
  generateFrontendABI()
    .then(() => {
      console.log("\n✓ Frontend ABI and addresses generated successfully!");
      process.exit(0);
    })
    .catch((error) => {
      console.error("Error generating frontend files:", error);
      process.exit(1);
    });
}

export default generateFrontendABI;

